//!
//! The httpserver capability provider allows wasmcloud actors to receive
//! and process http(s) messages from web browsers, command-line tools
//! such as curl, and other http clients. The server is fully asynchronous,
//! and built on Rust's high-performance warp engine, which is in turn based
//! on hyper, and can process a large number of simultaneous connections.
//!
//! ## Features:
//!
//! - HTTP/1 and HTTP/2
//! - TLS
//! - CORS support (select allowed_origins, allowed_methods,
//!   allowed_headers.) Cors has sensible defaults so it should
//!   work as-is for development purposes, and may need refinement
//!   for production if a more secure configuration is required.
//! - All settings can be specified at runtime, using per-actor link settings:
//!   - bind interface/port
//!   - logging level
//!   - TLS
//!   - Cors
//! - Flexible confiuration loading: from host, or from local toml or json file.
//! - Fully asynchronous, using tokio lightweight "green" threads
//! - Thread pool (for managing a pool of OS threads). The default
//!   thread pool has one thread per cpu core.
//! - Packaged as a rust library crate for implementation flexibility
//!
//! ## More tech info:
//!
//! Each actor that links to this provider gets
//! its own bind address (interface ip and port) and a lightweight
//! tokio thread (lighter weight than an OS thread, more like "green threads").
//! Tokio can manage a thread pool (of OS threads) to be shared
//! by the all of the server green threads.
//!
use std::{
    pin::Pin,
    time::Duration,
    {convert::Infallible, sync::Arc},
};

use bytes::Bytes;
use flume::{bounded, Receiver, Sender};
use futures::{Future, FutureExt};
use http::{header::HeaderMap, StatusCode};
use hyper::service::{make_service_fn, service_fn};
use hyper::{Body, Method, Request, Response, Server};
use thiserror::Error as ThisError;
use tokio::task::JoinHandle;
use tracing::{debug, error, info, trace, Instrument};
use warp::{filters::cors::Builder, path::FullPath, Filter};
use wasmbus_rpc::{core::LinkDefinition, error::RpcResult};
use wasmcloud_interface_httpserver::{HttpRequest, HttpResponse};

mod settings;
pub use settings::{load_settings, ServiceSettings, CONTENT_LEN_LIMIT, DEFAULT_MAX_CONTENT_LEN};
mod hashmap_ci;
pub(crate) use hashmap_ci::make_case_insensitive;

pub mod wasmcloud_interface_httpserver {
    smithy_bindgen::smithy_bindgen!(
        "httpserver/httpserver.smithy",
        "org.wasmcloud.interface.httpserver"
    );
}

/// errors generated by this crate
#[derive(ThisError, Debug)]
pub enum Error {
    #[error("invalid parameter: {0}")]
    InvalidParameter(String),

    #[error("problem reading settings: {0}")]
    Settings(String),

    #[error("provider startup: {0}")]
    Init(String),

    #[error("warp error: {0}")]
    Warp(warp::Error),

    #[error("deserializing settings: {0}")]
    SettingsToml(toml::de::Error),
}

pub type AsyncCallActorFn = Box<
    dyn Fn(
            String,
            Arc<LinkDefinition>,
            HttpRequest,
            Option<Duration>,
        ) -> Pin<Box<dyn Future<Output = RpcResult<HttpResponse>> + Send + 'static>>
        + Send
        + Sync,
>;

struct CallActorFn(AsyncCallActorFn);

pub struct Inner {
    settings: ServiceSettings,
    lattice_id: String,
    shutdown_tx: Sender<bool>,
    shutdown_rx: Receiver<bool>,
    call_actor: CallActorFn,
}

/// An asynchronous HttpServer with support for CORS and TLS
/// ```no_test
///   use wasmcloud_provider_httpserver::{HttpServer, load_settings};
///   let settings = load_settings(ld.values)?;
///   let server = HttpServer::new(settings);
///   let task = server.serve()?;
///   tokio::task::spawn(task);
/// ```
#[derive(Clone)]
pub struct HttpServerCore {
    inner: Arc<Inner>,
}

impl std::ops::Deref for HttpServerCore {
    type Target = Inner;
    fn deref(&self) -> &Self::Target {
        self.inner.as_ref()
    }
}

impl HttpServerCore {
    /// Initializes server with settings
    pub fn new<F, Fut>(settings: ServiceSettings, lattice_id: String, call_actor_fn: F) -> Self
    where
        F: Fn(String, Arc<LinkDefinition>, HttpRequest, Option<Duration>) -> Fut
            + Send
            + Sync
            + 'static,
        Fut: Future<Output = RpcResult<HttpResponse>> + 'static + Send,
    {
        let (shutdown_tx, shutdown_rx) = bounded(1);
        let call_actor_fn = Arc::new(call_actor_fn);
        Self {
            inner: Arc::new(Inner {
                settings,
                lattice_id,
                shutdown_tx,
                shutdown_rx,
                call_actor: CallActorFn(Box::new(
                    move |lattice: String,
                          ld: Arc<LinkDefinition>,
                          req: HttpRequest,
                          timeout: Option<Duration>| {
                        let call_actor_fn = call_actor_fn.clone();
                        Box::pin(call_actor_fn(lattice, ld, req, timeout))
                    },
                )),
            }),
        }
    }

    /// Initiate server shutdown. This can be called from any thread and is non-blocking.
    pub fn begin_shutdown(&self) {
        let _ = self.shutdown_tx.try_send(true);
    }

    /// Start the server in a new thread
    /// ```no_test
    ///    use wasmcloud_provider_httpserver::{HttpServer, load_settings};
    ///    let settings = load_settings(&ld.values)?;
    ///    let server = HttpServer::new(settings);
    ///    let _ = server.start().await?;
    /// ```
    pub async fn start(
        &self,
        ld: &LinkDefinition,
    ) -> Result<JoinHandle<Result<(), hyper::Error>>, Error> {
        let ld = Arc::new(ld.clone());
        let ld_clone = ld.clone();
        let inner = self.inner.clone();

        let make_svc = make_service_fn(move |_conn| {
            let inner_clone = inner.clone();
            let ld = ld_clone.clone();
            async move {
                Ok::<_, Infallible>(service_fn(move |req| {
                    handle_request(req, inner_clone.clone(), ld.clone())
                }))
            }
        });

        let addr = self.settings.address.unwrap();
        info!(
            %addr,
            actor_id = %ld.actor_id,
            "httpserver starting listener for actor",
        );

        let server = Server::bind(&addr).serve(make_svc);

        let handle = tokio::runtime::Handle::current();

        Ok(handle.spawn(server))
    }
}

async fn handle_request(
    req: Request<Body>,
    arc_inner: Arc<Inner>,
    ld: Arc<LinkDefinition>,
) -> Result<Response<Body>, Infallible> {
    let timeout = arc_inner
        .settings
        .timeout_ms
        .map(std::time::Duration::from_millis);
    let method = req.method().clone();
    let path = req.uri().path().to_owned();
    let query = req.uri().query().unwrap_or_default().to_owned();
    let headers = req.headers().clone();

    // Read-only mode check
    if let Some(readonly_mode) = arc_inner.settings.readonly_mode {
        if readonly_mode && method != Method::GET && method != Method::HEAD {
            let resp = Response::builder()
                .status(StatusCode::METHOD_NOT_ALLOWED)
                .body(Body::empty())
                .unwrap();
            return Ok(resp);
        }
    }

    // Convert headers
    let hmap = convert_request_headers(&headers);

    // Read the body
    let body_bytes = hyper::body::to_bytes(req.into_body())
        .await
        .unwrap_or_default();

    // Construct the HttpRequest
    let req = HttpRequest {
        body: body_bytes.to_vec(),
        header: hmap,
        method: method.as_str().to_ascii_uppercase(),
        path,
        query_string: query,
    };

    // Call actor and get response
    let response = match arc_inner
        .call_actor
        .call(arc_inner.lattice_id.clone(), ld.clone(), req, timeout)
        .await
    {
        Ok(resp) => resp,
        Err(e) => HttpResponse {
            status_code: http::StatusCode::INTERNAL_SERVER_ERROR.as_u16(),
            body: Default::default(),
            header: Default::default(),
        },
    };

    // Construct the hyper Response
    let mut builder = Response::builder().status(response.status_code);

    // Set cache control header if present
    if let Some(cache_control_header) = arc_inner.settings.cache_control.as_ref() {
        builder = builder.header("Cache-Control", cache_control_header);
    }

    // Convert response headers
    let mut hyper_response = builder.body(Body::from(response.body)).unwrap();
    convert_response_headers(response.header, hyper_response.headers_mut());

    Ok(hyper_response)
}

impl Drop for HttpServerCore {
    /// drop the client connection. Does not block or fail if the client has already been closed.
    fn drop(&mut self) {
        let _ = self.shutdown_tx.try_send(true);
    }
}

/// convert request headers from incoming warp server to HeaderMap
fn convert_request_headers(headers: &http::HeaderMap) -> wasmcloud_interface_httpserver::HeaderMap {
    let mut hmap = wasmcloud_interface_httpserver::HeaderMap::new();
    for k in headers.keys() {
        let vals = headers
            .get_all(k)
            .iter()
            // from http crate:
            //    In practice, HTTP header field values are usually valid ASCII.
            //     However, the HTTP spec allows for a header value to contain
            //     opaque bytes as well.
            // This implementation only forwards headers with ascii values to the actor.
            .filter_map(|val| val.to_str().ok())
            .map(|s| s.to_string())
            .collect::<Vec<_>>();
        if !vals.is_empty() {
            hmap.insert(k.to_string(), vals);
        }
    }
    hmap
}

/// convert HeaderMap from actor into warp's HeaderMap for returning to http client
fn convert_response_headers(
    header: wasmcloud_interface_httpserver::HeaderMap,
    headers_mut: &mut http::header::HeaderMap,
) {
    let map = headers_mut;
    for (k, vals) in header.into_iter() {
        let name = match http::header::HeaderName::from_bytes(k.as_bytes()) {
            Ok(name) => name,
            Err(e) => {
                error!(
                    header_name = %k,
                    error = %e,
                    "invalid response header name, sending without this header"
                );
                continue;
            }
        };
        map.remove(&name);
        for val in vals.into_iter() {
            let value = match http::header::HeaderValue::try_from(val) {
                Ok(value) => value,
                Err(e) => {
                    error!(
                        error = %e,
                        "Non-ascii header value, skipping this header"
                    );
                    continue;
                }
            };
            map.append(&name, value);
        }
    }
}

/// get raw query as string or optional query
fn opt_raw_query() -> impl Filter<Extract = (String,), Error = Infallible> + Copy {
    warp::any().and(
        warp::filters::query::raw()
            .or(warp::any().map(String::default))
            .unify(),
    )
}

/// build warp Cors filter from settings
fn cors_filter(settings: &settings::ServiceSettings) -> Result<warp::filters::cors::Cors, Error> {
    let mut cors: Builder = warp::cors();

    match settings.cors.allowed_origins {
        Some(ref allowed_origins) if !allowed_origins.is_empty() => {
            cors = cors.allow_origins(allowed_origins.iter().map(AsRef::as_ref));
        }
        _ => {
            cors = cors.allow_any_origin();
        }
    }

    if let Some(ref allowed_headers) = settings.cors.allowed_headers {
        cors = cors.allow_headers(allowed_headers.iter());
    }
    if let Some(ref allowed_methods) = settings.cors.allowed_methods {
        for m in allowed_methods.iter() {
            match http::method::Method::try_from(m.as_str()) {
                Err(_) => return Err(Error::InvalidParameter(format!("method: '{}'", m))),
                Ok(method) => {
                    cors = cors.allow_method(method);
                }
            }
        }
    }

    if let Some(ref exposed_headers) = settings.cors.exposed_headers {
        cors = cors.expose_headers(exposed_headers.iter());
    }

    if let Some(max_age) = settings.cors.max_age_secs {
        cors = cors.max_age(std::time::Duration::from_secs(max_age));
    }
    Ok(cors.build())
}

/// Convert setting for max content length of form '[0-9]+(g|G|m|M|k|K)?'
/// Empty string is accepted and returns the default value (currently '10M')
pub fn convert_human_size(value: &str) -> Result<u64, Error> {
    let value = value.trim();
    let mut limit = None;
    if value.is_empty() {
        limit = Some(DEFAULT_MAX_CONTENT_LEN);
    } else if let Ok(num) = value.parse::<u64>() {
        limit = Some(num);
    } else {
        let (num, units) = value.split_at(value.len() - 1);
        if let Ok(base_value) = num.trim().parse::<u64>() {
            match units {
                "k" | "K" => {
                    limit = Some(base_value * 1024);
                }
                "m" | "M" => {
                    limit = Some(base_value * 1024 * 1024);
                }
                "g" | "G" => {
                    limit = Some(base_value * 1024 * 1024 * 1024);
                }
                _ => {}
            }
        }
    }
    match limit {
        Some(x) if x > 0 && x <= CONTENT_LEN_LIMIT => Ok(x),
        Some(_) => {
            Err(Error::Settings(format!("Invalid size in max_content_len '{}': value must be >0 and <= {}", value, settings::CONTENT_LEN_LIMIT)))
        }
        None => {
            Err(Error::Settings(format!("Invalid size in max_content_len: '{}'. Should be a number, optionally followed by 'K', 'M', or 'G'. Example: '10M'. Value must be <= i32::MAX", value)))
        }
    }
}

impl CallActorFn {
    fn call(
        &self,
        lattice_id: String,
        ld: Arc<LinkDefinition>,
        req: HttpRequest,
        timeout: Option<Duration>,
    ) -> Pin<Box<dyn Future<Output = RpcResult<HttpResponse>> + Send + 'static>> {
        Box::pin((self.0.as_ref())(lattice_id, ld, req, timeout))
    }
}

#[test]
fn parse_max_content_len() {
    // emtpy string returns default
    assert_eq!(convert_human_size("").unwrap(), DEFAULT_MAX_CONTENT_LEN);
    // simple number
    assert_eq!(convert_human_size("4").unwrap(), 4);
    assert_eq!(convert_human_size("12345678").unwrap(), 12345678);
    // k, K, m, M, g, G suffix
    assert_eq!(convert_human_size("2k").unwrap(), 2 * 1024);
    assert_eq!(convert_human_size("2K").unwrap(), 2 * 1024);
    assert_eq!(convert_human_size("10m").unwrap(), 10 * 1024 * 1024);
    assert_eq!(convert_human_size("10M").unwrap(), 10 * 1024 * 1024);

    // allow space before units
    assert_eq!(convert_human_size("10 M").unwrap(), 10 * 1024 * 1024);

    // remove surrounding white space
    assert_eq!(convert_human_size(" 5 k ").unwrap(), 5 * 1024);

    // errors
    assert!(convert_human_size("k").is_err());
    assert!(convert_human_size("0").is_err());
    assert!(convert_human_size("1mb").is_err());
    assert!(convert_human_size(&i32::MAX.to_string()).is_err());
    assert!(convert_human_size(&(i32::MAX as u64 + 1).to_string()).is_err());
}
